"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[958],{5305:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"seq-db/internal/parser","title":"How search request parsing works","description":"Query language","source":"@site/docs/seq-db/internal/parser.md","sourceDirName":"seq-db/internal","slug":"/seq-db/internal/parser","permalink":"/seq-db-docs/seq-db/internal/parser","draft":false,"unlisted":false,"editUrl":"https://github.com/ozontech/seq-db/tree/main/website/docs/docs/seq-db/internal/parser.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Factions","permalink":"/seq-db-docs/seq-db/internal/fractions"},"next":{"title":"How searching works","permalink":"/seq-db-docs/seq-db/internal/search"}}');var i=s(4848),t=s(8453);const a={},o="How search request parsing works",l={},d=[{value:"Query language",id:"query-language",level:2},{value:"Parsing overview",id:"parsing-overview",level:2},{value:"NOT propogation",id:"not-propogation",level:2},{value:"Terminology",id:"terminology",level:2}];function c(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"how-search-request-parsing-works",children:"How search request parsing works"})}),"\n",(0,i.jsx)(n.h2,{id:"query-language",children:"Query language"}),"\n",(0,i.jsx)(n.p,{children:"Our query language is similar to the Apache Lucene, but it has some differences."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In the base of the request are ",(0,i.jsx)(n.code,{children:"field queries"}),": they can be ",(0,i.jsx)(n.code,{children:"literal"})," type or ",(0,i.jsx)(n.code,{children:"range"})," type. These queries have ",(0,i.jsx)(n.code,{children:"field"})," and ",(0,i.jsx)(n.code,{children:"request"})," parts. They ask for all documents, that have ",(0,i.jsx)(n.code,{children:"field"}),", that satisfies ",(0,i.jsx)(n.code,{children:"request"})," (string matches/range matches/wildcard matches). They also can have wildcards.\nRange boundaries can be inclusive and non-inclusive"]}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"service: alertagent"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'service:"cms-api"'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'message:"protobuf error"'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'service:"cms*api"'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'message:"proto* error"'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"level: 3"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"level:[3 TO 5]"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"level:[3 TO *]"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"level:{1 TO 5}"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Then you can unite the subqueries wia logical operators: ",(0,i.jsx)(n.code,{children:"*query* AND *query*"})," / ",(0,i.jsx)(n.code,{children:"*query* OR *query*"})," / ",(0,i.jsx)(n.code,{children:"NOT *query*"}),". They are pretty straitforward. NOT has the highest priority, AND has second and OR has third."]}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a AND m:b"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"NOT m:a"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a OR m:b AND m:c AND NOT m:d OR m:e"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Also you can use brackets to change operators priority"}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a AND (m:b OR m:c)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a AND NOT (m:b OR m:c) OR m:d"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"m:a AND NOT ((m:b OR m:c) OR m:d)"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"parsing-overview",children:"Parsing overview"}),"\n",(0,i.jsxs)(n.p,{children:["Entrypoint is ",(0,i.jsx)(n.code,{children:"parser/query_parser.go/ParseQuery"})," in ",(0,i.jsx)(n.code,{children:"parser.go"}),". There are also several other variants, including ones used for testing purposes."]}),"\n",(0,i.jsx)(n.p,{children:"This is Recursive descent parser.\nThere's basic TokenParser, capable of parsing single Token (literal or range).\nAnd there's QueryParser, which embeds TokenParser, that one is responsible for\nparsing the query, and doing 'not propagation' step afterward."}),"\n",(0,i.jsx)(n.p,{children:"Due to differences in parsing Term's for different types of field, there's\ntermBuilder interface, which implementations are essentially event-based parsers."}),"\n",(0,i.jsx)(n.h2,{id:"not-propogation",children:"NOT propogation"}),"\n",(0,i.jsx)(n.p,{children:"This is a nice, but complex optimization, so let's talk about it a little more."}),"\n",(0,i.jsxs)(n.p,{children:["AND and OR operations are fast in a way that they work in ",(0,i.jsx)(n.code,{children:"O(len(left)+len(right))"})," complexity. NOT is slow, because it works in ",(0,i.jsx)(n.code,{children:"O(len(documents))"})," (in a fraction) complexity, and not in ",(0,i.jsx)(n.code,{children:"O(len(child))"}),". You can also see, that ",(0,i.jsx)(n.code,{children:"NOT *query* AND *query*"})," (AND with only one NOT child) operation can be evaluated efficiently."]}),"\n",(0,i.jsxs)(n.p,{children:["And also there are De Morgan Laws, that helps us propagate NOT: ",(0,i.jsx)(n.code,{children:"NOT (a AND b) == (NOT a OR NOT b)"})," / ",(0,i.jsx)(n.code,{children:"NOT (a OR b) == (NOT a AND NOT b)"})]}),"\n",(0,i.jsx)(n.p,{children:"These two observations give us an ability to propagate NOT to the root of the query. Algorithm is simple, you traverse the AST tree from the leaves upwards, and check some rules:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If the node is AND","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If it has 2 NOT childs, apply De Morgan laws to this AND (so, replace the 2 NOT nodes with just their childs, replace AND to OR and add a NOT at the root of current node)"}),"\n",(0,i.jsx)(n.li,{children:"If it has 1 NOT child, make this NAND (NOT AND) node, meaning this is a special node, that can evaluate this expression in a fast manner"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If the node is OR","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If it has at least 1 NOT child, apply De Morgan laws. If this node had 2 childs, the NOT is propagated above. But if it has only 1 child, this node becomes NAND node in the end."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Else do nothing"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This algorithm gurantees, that after it there will be some NAND nodes and ",(0,i.jsx)(n.code,{children:"<= 1"})," NOT node, which is good: we can reduce an arbitrary numbers of NOT nodes into not more than 1."]}),"\n",(0,i.jsx)(n.p,{children:"Here is a query with two NOT operations:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"AST tree",src:s(7001).A+"",width:"881",height:"396"})}),"\n",(0,i.jsx)(n.p,{children:"We start at the right OR and change it according to the rules:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"AST tree",src:s(2800).A+"",width:"933",height:"441"})}),"\n",(0,i.jsx)(n.p,{children:"This AND with one NOT child becomes NAND node, and we also added (propagated) NOT above, so now we go to the root AND node:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"AST tree",src:s(363).A+"",width:"936",height:"451"})}),"\n",(0,i.jsx)(n.p,{children:"In the end, we are left with one NOT node at the top, with which we can't do anything, so it leaves there."}),"\n",(0,i.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Token - part of query responsible for one field.\nThere's literal token, which consists of Field and Terms,\nand there's range token, which consists of Field and unnamed right part."}),"\n",(0,i.jsxs)(n.li,{children:["Field - the left part of the query on fields: ",(0,i.jsx)(n.code,{children:"*field*:terms"})]}),"\n",(0,i.jsxs)(n.li,{children:["Terms - the right part of the query on fields: ",(0,i.jsx)(n.code,{children:"field:*terms*"}),(0,i.jsx)(n.br,{}),"\n","There can be additional parsing done, like parsing the wildcards, ranges, spaces, etc."]}),"\n",(0,i.jsx)(n.li,{children:"AST - abstract syntax tree. See images above for an example. It does know the order of the operations and how operations relate to each other."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},7001:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/tree_0-0eb50857dcea1d6587f187a53452ee75.png"},2800:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/tree_1-0684052888c86588c4fbe48baf1a8e92.png"},363:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/tree_2-1edd0cdd0d11ac134b6c716e8526129e.png"},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);