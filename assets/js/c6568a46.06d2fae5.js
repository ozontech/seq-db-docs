"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[697],{8382:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"seq-db/rate-limiting","title":"Rate limiting requests","description":"Obviously there is a need to rate limit some requests from users or other","source":"@site/docs/seq-db/08-rate-limiting.md","sourceDirName":"seq-db","slug":"/seq-db/rate-limiting","permalink":"/seq-db-docs/seq-db/rate-limiting","draft":false,"unlisted":false,"editUrl":"https://github.com/ozontech/seq-db/tree/main/website/docs/docs/seq-db/08-rate-limiting.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"id":"rate-limiting"},"sidebar":"docs","previous":{"title":"Long term stores","permalink":"/seq-db-docs/seq-db/long-term-store"},"next":{"title":"Troubleshooting","permalink":"/seq-db-docs/seq-db/troubleshooting"}}');var s=i(4848),r=i(8453);const o={id:"rate-limiting"},a="Rate limiting requests",l={},c=[{value:"Rate limiting search queries",id:"rate-limiting-search-queries",level:2},{value:"Rate limiting document fetching",id:"rate-limiting-document-fetching",level:2},{value:"How to enable the rate limiter",id:"how-to-enable-the-rate-limiter",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"rate-limiting-requests",children:"Rate limiting requests"})}),"\n",(0,s.jsxs)(t.p,{children:["Obviously there is a need to rate limit some requests from users or other\nservices. Right now we use simple internal implementation of RateLimiter,\nsee ",(0,s.jsx)(t.code,{children:"network/ratelimiter.go"}),", it is enough\nfor current tasks. Following sections describe the use cases for\nrate limiter."]}),"\n",(0,s.jsx)(t.h2,{id:"rate-limiting-search-queries",children:"Rate limiting search queries"}),"\n",(0,s.jsxs)(t.p,{children:["Because of bugs in UI or script automation there is a possibility of\nrepeating the same search query multiple times. Search query may create\na significant load on stores, and to evade useless work, search queries\nare rate limited by stores. Two queries are considered identical if they\nhave same query string, aggregation and interval. This is implemented in\n",(0,s.jsx)(t.code,{children:"search_store.go"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"rate-limiting-document-fetching",children:"Rate limiting document fetching"}),"\n",(0,s.jsxs)(t.p,{children:["There are 2 cases of document fetching, first is made after search query\nfound IDs and fetching is needed to return results to user. Second is\nwhen document is directly requested from API on ingestor. Second way\nis vulnerable to DDOS kind of attack, because fetching by ID is not\nsimple operation for now. So rate limiter is implemented to throttle\nsuch requests by message ID. This is implemented in\n",(0,s.jsx)(t.code,{children:"search_proxy.go"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"how-to-enable-the-rate-limiter",children:"How to enable the rate limiter"}),"\n",(0,s.jsxs)(t.p,{children:["The rate limiter can be enabled on launch using the ",(0,s.jsx)(t.code,{children:"query-rate-limit"})," flag\nfollowed by a number -- the maximum number of queries allowed per second.\nThe default value for this flag is ",(0,s.jsx)(t.code,{children:"2.0"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>a});var n=i(6540);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);